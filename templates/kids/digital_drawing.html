<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Digital Drawing</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
  <style>
  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #fff;
    box-sizing: border-box;
    border: 8px solid #00b8ff;
    border-radius: 40px;
    box-shadow: 0 4px 32px #00b8ff22;
  }
  #drawingCanvas { position: absolute; top: 80px; left: 0; width: 100vw; height: calc(100vh - 80px); background: #fff; display: block; cursor: crosshair; z-index: 1; }
  .drawing-toolbar {
    position: sticky;
  top: 120px;
    left: 0;
    width: 100vw;
    min-height: 80px;
    background: #f8f9fa;
    border-bottom: 2px solid #00b8ff;
    box-shadow: 0 4px 16px #00b8ff33;
    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
    align-items: flex-start;
    z-index: 100;
    padding: 8px 8px 8px 8px;
  border-radius: 32px;
  }
  .toolbar-row {
    display: flex;
    flex-direction: row;
    gap: 16px;
    align-items: center;
    width: 100%;
    margin-bottom: 4px;
    justify-content: flex-start;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: thin;
    scrollbar-color: #00b8ff #e0e0e0;
  }
  .toolbar-section { display: flex; flex-direction: column; align-items: flex-start; justify-content: center; min-width: 120px; }
  .toolbar-actions { display: flex; flex-direction: row; gap: 6px; align-items: center; margin-top: 0; margin-bottom: 0; }
  .drawing-toolbar label, .drawing-toolbar select, .drawing-toolbar button, .drawing-toolbar .tool-btn, .drawing-toolbar .kids-btn { margin: 0 2px; font-size: 1rem; }
  .drawing-toolbar label, .drawing-toolbar select, .drawing-toolbar button, .drawing-toolbar .tool-btn, .drawing-toolbar .kids-btn { margin: 0 6px; font-size: 2.2rem; }
  .tool-btn {
    background: #fff;
    color: #00b8ff;
    border: 2px solid #00b8ff;
    padding: 16px 24px;
    border-radius: 18px;
    min-width: 72px;
    min-height: 72px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    box-shadow: 0 2px 8px #00b8ff22;
    transition: background 0.2s, color 0.2s, box-shadow 0.2s;
    margin-bottom: 2px;
  }
  .tool-btn.active {
    background: #00b8ff;
    color: #fff;
    box-shadow: 0 4px 16px #00b8ff44;
  }
  .kids-btn {
    background: #fff;
    color: #00b8ff;
    border: 2px solid #00b8ff;
    padding: 16px 24px;
    border-radius: 18px;
    min-width: 72px;
    min-height: 72px;
    font-weight: 700;
    font-size: 2rem;
    box-shadow: 0 2px 8px #00b8ff22;
    margin-bottom: 2px;
  }
  .kids-btn.save { background:#00b8ff;color:#fff; }
  .drawing-toolbar select, .drawing-toolbar input[type="color"], .drawing-toolbar input[type="range"] { height: 48px; font-size: 1.4rem; }
  .drawing-toolbar label { font-weight: 700; }
  .drawing-toolbar::-webkit-scrollbar { height: 8px; background: #e0e0e0; }
  .drawing-toolbar::-webkit-scrollbar-thumb { background: #00b8ff; border-radius: 4px; }
  @media (max-width: 1200px) { .toolbar-row { gap: 6px; } .tool-btn, .kids-btn { min-width: 28px; font-size: 0.95rem; padding: 3px 6px; } }
  @media (max-width: 767px) { .drawing-toolbar { font-size: 0.85rem; padding: 0 2px; } .toolbar-row { gap: 3px; } .tool-btn, .kids-btn { min-width: 24px; font-size: 0.8rem; padding: 2px 2px; } }
  @media (orientation: landscape) and (max-width: 900px) {
    .drawing-toolbar {
      min-height: 40px;
      height: 40px;
      padding-top: 2px;
      padding-bottom: 2px;
    }
    .tool-btn, .kids-btn {
      min-width: 40px;
      min-height: 40px;
      padding: 4px 8px;
      font-size: 1rem;
    }
    .drawing-toolbar label, .drawing-toolbar select, .drawing-toolbar button, .drawing-toolbar .tool-btn, .drawing-toolbar .kids-btn {
      font-size: 1rem;
    }
  }
  </style>
</head>
<body>
<div class="drawing-toolbar">
  <div class="toolbar-row">
    <label>Brush Size:
      <input type="range" id="brushSize" min="1" max="64" value="6">
    </label>
    <label>Brush Color:
      <input type="color" id="brushColor" value="#000000">
    </label>
    <label>Brush Type:
      <select id="brushType">
        <option value="pencil">Pencil</option>
        <option value="charcoal">Charcoal</option>
        <option value="graphite">Graphite</option>
        <option value="ink">Ink Pen</option>
        <option value="marker">Marker</option>
        <option value="airbrush">Airbrush</option>
        <option value="calligraphy">Calligraphy</option>
        <option value="eraser">Eraser</option>
        <option value="smudge">Smudge</option>
        <option value="blend">Blend</option>
        <option value="spray">Spray</option>
        <option value="pattern">Pattern Brush</option>
        <option value="dotted">Dotted Line</option>
        <option value="hatch">Hatching</option>
        <option value="crosshatch">Crosshatch</option>
      </select>
    </label>
    <label style="font-size:1.2rem; margin-left:16px;">
      Load Image:
      <input type="file" id="imageLoader" accept="image/*" style="font-size:1.2rem; padding:4px;">
    </label>
  </div>
  <div class="toolbar-row">
  <button onclick="setTool('gradient')" id="gradientBtn" class="tool-btn" title="Gradient Brush"><i class="fas fa-adjust"></i></button>
  <button onclick="setTool('pattern')" id="patternBtn" class="tool-btn" title="Pattern/Texture Brush"><i class="fas fa-grip-lines"></i></button>
  <button onclick="setTool('rainbow')" id="rainbowBtn" class="tool-btn" title="Rainbow Brush"><i class="fas fa-rainbow"></i></button>
  <button onclick="setTool('picker')" id="pickerBtn" class="tool-btn" title="Color Picker"><i class="fas fa-eye-dropper"></i></button>
  <button onclick="setTool('blur')" id="blurBtn" class="tool-btn" title="Blur Tool"><i class="fas fa-low-vision"></i></button>
  <button onclick="setTool('smudge')" id="smudgeBtn" class="tool-btn" title="Smudge Tool"><i class="fas fa-hand-paper"></i></button>
  <button onclick="setTool('curve')" id="curveBtn" class="tool-btn" title="Curve Tool"><i class="fas fa-wave-square"></i></button>
  </div>
  <div class="toolbar-row">
  <button onclick="setTool('brush')" id="brushBtn" class="tool-btn active" title="Sketch"><i class="fas fa-pencil-alt"></i></button>
  <button onclick="setTool('line')" id="lineBtn" class="tool-btn" title="Line"><i class="fas fa-slash"></i></button>
  <button onclick="setTool('rect')" id="rectBtn" class="tool-btn" title="Rectangle"><i class="far fa-square"></i></button>
  <button onclick="setTool('circle')" id="circleBtn" class="tool-btn" title="Circle"><i class="far fa-circle"></i></button>
  <button onclick="setTool('mirror')" id="mirrorBtn" class="tool-btn" title="Mirror Tool"><i class="fas fa-columns"></i></button>
  <button onclick="setTool('fill')" id="fillBtn" class="tool-btn" title="Fill"><i class="fas fa-fill-drip"></i></button>
  <button onclick="setTool('text')" id="textBtn" class="tool-btn" title="Text"><i class="fas fa-font"></i></button>
  <span style="display:inline-block;min-width:48px;"></span>
  <button onclick="clearCanvas()" class="kids-btn" title="Clear" style="margin-left:32px;"><i class="fas fa-trash"></i></button>
  <button onclick="saveDrawing()" class="kids-btn save" title="Save" style="margin-left:12px;"><i class="fas fa-save"></i></button>
  <button onclick="undo()" class="kids-btn" title="Undo" style="margin-left:12px;"><i class="fas fa-undo"></i></button>
  <button onclick="redo()" class="kids-btn" title="Redo" style="margin-left:12px;"><i class="fas fa-redo"></i></button>
  <span id="saveMsg" style="color:#00b8ff;font-weight:600;"></span>
  </div>
  <div class="toolbar-row">
  </div>
</div>
<div id="levelSampleImg" style="position:fixed;top:240px;left:23px;z-index:9998;display:none;"></div>
<canvas id="drawingCanvas" width="1920" height="1080"></canvas>
<canvas id="previewCanvas" width="1920" height="1080" style="position:absolute;top:80px;left:0;width:100vw;height:calc(100vh - 80px);pointer-events:none;z-index:2;"></canvas>

<div id="modeSelect" class="kids-modal">
  <h2 class="kids-title">üé® Choose Drawing Mode</h2>
  <div class="kids-mode-btns">
    <button onclick="startSelfDrawing()" class="kids-mode-btn self">üñåÔ∏è Self Drawing</button>
    <button onclick="showLevelChooser()" class="kids-mode-btn levels">üåü Levels Mode</button>
  </div>
</div>
<div id="levelChooser" class="kids-modal" style="display:none;">
  <h2 class="kids-title">üåü Choose a Level</h2>
  <div id="levelBtns" class="kids-level-btns kids-level-btns-scroll"></div>
  <button onclick="backToModeSelect()" class="kids-back-btn">‚¨ÖÔ∏è Back</button>
</div>

<script>
  const previewCanvas = document.getElementById('previewCanvas');
  const previewCtx = previewCanvas.getContext('2d');
  const canvas = document.getElementById('drawingCanvas');
  const ctx = canvas.getContext('2d');
  let drawing = false, tool = 'brush', startX = 0, startY = 0, brushSize = 6, brushColor = '#000000', snapshot = null;
  let brushType = document.getElementById('brushType').value;
  let history = [], redoStack = [];
  let lastDotX = null, lastDotY = null;
  let polygonPoints = [];
  let isDrawingPolygon = false;
  let selectedArea = null;

  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    previewCanvas.width = rect.width;
    previewCanvas.height = rect.height;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  function setTool(selected) {
    tool = selected;
    document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
    if(selected==='brush') document.getElementById('brushBtn').classList.add('active');
    if(selected==='gradient') document.getElementById('gradientBtn').classList.add('active');
    if(selected==='pattern') document.getElementById('patternBtn').classList.add('active');
    if(selected==='rainbow') document.getElementById('rainbowBtn').classList.add('active');
    if(selected==='picker') document.getElementById('pickerBtn').classList.add('active');
    if(selected==='blur') document.getElementById('blurBtn').classList.add('active');
    if(selected==='smudge') document.getElementById('smudgeBtn').classList.add('active');
    if(selected==='mirror') document.getElementById('mirrorBtn').classList.add('active');
    if(selected==='curve') document.getElementById('curveBtn').classList.add('active');
    if(selected==='line') document.getElementById('lineBtn').classList.add('active');
    if(selected==='rect') document.getElementById('rectBtn').classList.add('active');
    if(selected==='circle') document.getElementById('circleBtn').classList.add('active');
    if(selected==='ellipse') document.getElementById('ellipseBtn').classList.add('active');
    if(selected==='polygon') document.getElementById('polygonBtn').classList.add('active');
    if(selected==='fill') document.getElementById('fillBtn').classList.add('active');
    if(selected==='text') document.getElementById('textBtn').classList.add('active');
  }

  document.getElementById('brushSize').addEventListener('input', function() { brushSize = this.value; });
  document.getElementById('brushColor').addEventListener('input', function() { brushColor = this.value; });
  document.getElementById('brushType').addEventListener('change', function() { brushType = this.value; });

  function getXY(e) {
    const rect = canvas.getBoundingClientRect();
    let x, y;
    if (e.touches) {
      x = e.touches[0].clientX - rect.left;
      y = e.touches[0].clientY - rect.top;
    } else {
      x = e.clientX - rect.left;
      y = e.clientY - rect.top;
    }
    return { x, y };
  }

  function saveState() {
    history.push(canvas.toDataURL());
    if(history.length > 50) history.shift();
    redoStack = [];
  }
  function undo() {
    if(history.length < 2) return;
    redoStack.push(history.pop());
    let img = new Image();
    img.src = history[history.length-1];
    img.onload = ()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0,canvas.width,canvas.height); };
  }
  function redo() {
    if(redoStack.length === 0) return;
    let img = new Image();
    img.src = redoStack.pop();
    img.onload = ()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0,canvas.width,canvas.height); history.push(img.src); };
  }

  // Add custom text input box
  const textInputBox = document.createElement('div');
  textInputBox.style.position = 'fixed';
  textInputBox.style.display = 'none';
  textInputBox.style.zIndex = '1000';
  textInputBox.innerHTML = `
    <input id="canvasTextInput" type="text" style="font-size:1.2rem;padding:6px 12px;border-radius:8px;border:1px solid #00b8ff;outline:none;" placeholder="Enter text...">
    <button id="canvasTextOk" style="font-size:1.1rem;padding:6px 16px;margin-left:8px;background:#00b8ff;color:#fff;border:none;border-radius:8px;">OK</button>
    <button id="canvasTextCancel" style="font-size:1.1rem;padding:6px 16px;margin-left:4px;background:#eee;color:#333;border:none;border-radius:8px;">Cancel</button>
  `;
  document.body.appendChild(textInputBox);
  let textInputPos = {x:0, y:0};

  function showTextInput(x, y) {
    textInputBox.style.left = (x + 20) + 'px';
    textInputBox.style.top = (y + 80) + 'px';
    textInputBox.style.display = 'block';
    document.getElementById('canvasTextInput').value = '';
    document.getElementById('canvasTextInput').focus();
    textInputPos = {x, y};
    // Draw a temporary dot for reference
    ctx.save();
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, 2 * Math.PI);
    ctx.fillStyle = '#00b8ff';
    ctx.globalAlpha = 0.7;
    ctx.fill();
    ctx.restore();
  }
  function hideTextInput() {
    textInputBox.style.display = 'none';
  }
  document.getElementById('canvasTextOk').onclick = function() {
    const val = document.getElementById('canvasTextInput').value;
    if(val) {
      // Remove reference dot by redrawing last saved state
      let img = new Image();
      img.src = history[history.length-1];
      img.onload = function() {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(img,0,0,canvas.width,canvas.height);
        ctx.font = `${brushSize*3}px Arial`;
        ctx.fillStyle = brushColor;
        ctx.fillText(val, textInputPos.x, textInputPos.y);
        saveState();
      };
    }
    hideTextInput();
  };
  document.getElementById('canvasTextCancel').onclick = function() { hideTextInput(); };

  function startDraw(e) {
    if(tool==='curve') {
      const {x, y} = getXY(e);
      if (!window.curvePoints) window.curvePoints = [];
      window.curvePoints.push({x, y});
      previewCtx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
      if(window.curvePoints.length === 2) {
        // Show preview: dashed line from start to control, and a faint curve to mouse
        previewCtx.save();
        previewCtx.lineWidth = brushSize/2;
        previewCtx.strokeStyle = '#00b8ff';
        previewCtx.setLineDash([5,5]);
        previewCtx.beginPath();
        previewCtx.moveTo(window.curvePoints[0].x, window.curvePoints[0].y);
        previewCtx.lineTo(window.curvePoints[1].x, window.curvePoints[1].y);
        previewCtx.stroke();
        previewCtx.setLineDash([]);
        previewCtx.globalAlpha = 0.5;
        previewCtx.beginPath();
        previewCtx.moveTo(window.curvePoints[0].x, window.curvePoints[0].y);
        previewCtx.quadraticCurveTo(window.curvePoints[1].x, window.curvePoints[1].y, x, y);
        previewCtx.stroke();
        previewCtx.restore();
      }
      if(window.curvePoints.length === 3) {
        ctx.save();
        ctx.lineWidth = brushSize;
        ctx.strokeStyle = brushColor;
        ctx.beginPath();
        ctx.moveTo(window.curvePoints[0].x, window.curvePoints[0].y);
        ctx.quadraticCurveTo(
          window.curvePoints[1].x, window.curvePoints[1].y,
          window.curvePoints[2].x, window.curvePoints[2].y
        );
        ctx.stroke();
        ctx.restore();
        window.curvePoints = undefined;
        previewCtx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
      }
      return;
    }
    drawing = true;
    const {x, y} = getXY(e);
    startX = x; startY = y;
    if(tool==='brush') {
      lastDotX = null; lastDotY = null;
      draw(e);
    }
    if(tool==='picker') {
      // Color picker: pick color instantly on mouse down
      let px = Math.floor(x), py = Math.floor(y);
      let imageData = ctx.getImageData(px, py, 1, 1).data;
      let rgb = `#${((1<<24)+(imageData[0]<<16)+(imageData[1]<<8)+imageData[2]).toString(16).slice(1)}`;
      brushColor = rgb;
      document.getElementById('brushColor').value = rgb;
      drawing = false;
      return;
    }
    if(tool==='fill') floodFill(x, y, brushColor);
    if(['line','rect','circle','ellipse','polygon'].includes(tool)) snapshot = ctx.getImageData(0,0,canvas.width,canvas.height);
    if(tool==='text') {
      showTextInput(x, y);
      drawing = false;
      ctx.beginPath();
      return;
    }
    saveState();
  }
  function endDraw(e) {
    if(!drawing) return;
    drawing = false;
    if(['line','rect','circle','ellipse','polygon'].includes(tool)) drawShape(e,true);
    if(tool==='text') drawShape(e,true);
    ctx.beginPath();
  }

  canvas.addEventListener('mousedown', startDraw);
  canvas.addEventListener('mouseup', endDraw);
  canvas.addEventListener('mouseout', endDraw);
  canvas.addEventListener('mousemove', draw);
  canvas.addEventListener('touchstart', function(e) { drawing = true; startDraw(e); });
  canvas.addEventListener('touchend', endDraw);
  canvas.addEventListener('touchcancel', endDraw);
  canvas.addEventListener('touchmove', draw);

  function draw(e) {
    // ...existing code...
    if(tool==='mirror') {
      if (!drawing) return;
      const {x, y} = getXY(e);
      // Draw at cursor and mirrored across vertical axis
      ctx.save();
      ctx.lineWidth = brushSize;
      ctx.lineCap = 'round';
      ctx.strokeStyle = brushColor;
      ctx.beginPath();
      ctx.moveTo(lastDotX ?? startX, lastDotY ?? startY);
      ctx.lineTo(x, y);
      ctx.stroke();
      // Mirror
      let mx = canvas.width - (lastDotX ?? startX);
      let mx2 = canvas.width - x;
      ctx.beginPath();
      ctx.moveTo(mx, y);
      ctx.lineTo(mx2, y);
      ctx.stroke();
      ctx.restore();
      lastDotX = x;
      lastDotY = y;
      return;
    }
    if(tool==='smudge') {
      if (!drawing) return;
      const {x, y} = getXY(e);
      let px = Math.floor(x), py = Math.floor(y);
      let r = Math.max(8, brushSize * 2);
      let imageData = ctx.getImageData(px - r, py - r, r * 2, r * 2);
      let data = imageData.data;
      let w = r * 2, h = r * 2;
      // Smudge: average colors and shift them slightly in the direction of movement
      if (typeof draw.lastX === 'number' && typeof draw.lastY === 'number') {
        let dx = px - draw.lastX;
        let dy = py - draw.lastY;
        for(let y0=1; y0<h-1; y0++) {
          for(let x0=1; x0<w-1; x0++) {
            let i = (y0*w + x0)*4;
            let srcX = Math.max(0, Math.min(w-1, x0 - Math.sign(dx)));
            let srcY = Math.max(0, Math.min(h-1, y0 - Math.sign(dy)));
            let srcIdx = (srcY*w + srcX)*4;
            for(let c=0; c<4; c++) {
              data[i+c] = (data[i+c] + data[srcIdx+c]) / 2;
            }
          }
        }
      }
      ctx.putImageData(imageData, px - r, py - r);
      draw.lastX = px;
      draw.lastY = py;
      return;
    } else {
      draw.lastX = undefined;
      draw.lastY = undefined;
    }
    if(tool==='blur') {
      if (!drawing) return;
      // Improved blur tool: apply a stronger blur using multiple passes
      const {x, y} = getXY(e);
      let px = Math.floor(x), py = Math.floor(y);
      let r = Math.max(8, brushSize * 2);
      let imageData = ctx.getImageData(px - r, py - r, r * 2, r * 2);
      let data = imageData.data;
      let w = r * 2, h = r * 2;
      // Apply blur in multiple passes for stronger effect
      for(let pass=0; pass<4; pass++) {
        let temp = new Uint8ClampedArray(data);
        for(let y0=1; y0<h-1; y0++) {
          for(let x0=1; x0<w-1; x0++) {
            let i = (y0*w + x0)*4;
            let totalR=0, totalG=0, totalB=0, totalA=0;
            for(let dy=-1; dy<=1; dy++) {
              for(let dx=-1; dx<=1; dx++) {
                let idx = ((y0+dy)*w + (x0+dx))*4;
                totalR += temp[idx];
                totalG += temp[idx+1];
                totalB += temp[idx+2];
                totalA += temp[idx+3];
              }
            }
            data[i] = totalR/9;
            data[i+1] = totalG/9;
            data[i+2] = totalB/9;
            data[i+3] = totalA/9;
          }
        }
      }
      ctx.putImageData(imageData, px - r, py - r);
      return;
    }
    if (!drawing) return;
    const {x, y} = getXY(e);
    // Painting tools
    if(tool==='gradient') {
      // Gradient brush: radial gradient at cursor
      const grad = ctx.createRadialGradient(x, y, 0, x, y, brushSize);
      grad.addColorStop(0, brushColor);
      grad.addColorStop(1, '#fff');
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, brushSize, 0, 2*Math.PI);
      ctx.fillStyle = grad;
      ctx.globalAlpha = 0.8;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.restore();
      return;
    }
    if(tool==='pattern') {
      // Pattern/Texture brush: checkerboard
      ctx.save();
      for(let dx=-brushSize; dx<brushSize; dx+=brushSize/2) {
        for(let dy=-brushSize; dy<brushSize; dy+=brushSize/2) {
          ctx.beginPath();
          ctx.rect(x+dx, y+dy, brushSize/2, brushSize/2);
          ctx.fillStyle = ((Math.floor(dx/(brushSize/2))+Math.floor(dy/(brushSize/2)))%2===0)?brushColor:'#fff';
          ctx.globalAlpha = 0.7;
          ctx.fill();
        }
      }
      ctx.globalAlpha = 1;
      ctx.restore();
      return;
    }
    if(tool==='rainbow') {
      // Rainbow brush: concentric colored arcs
      ctx.save();
      let rainbowColors = ['#ff0000','#ff7f00','#ffff00','#00ff00','#0000ff','#4B0082','#9400D3'];
      for(let i=0; i<rainbowColors.length; i++) {
        ctx.beginPath();
        ctx.arc(x, y, brushSize/2 - i*2, 0, 2*Math.PI);
        ctx.strokeStyle = rainbowColors[i];
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      ctx.lineWidth = brushSize;
      ctx.strokeStyle = brushColor;
      ctx.restore();
      return;
    }
    if(tool==='picker') {
      // Color picker (eyedropper)
      let px = Math.floor(x), py = Math.floor(y);
      let imageData = ctx.getImageData(px, py, 1, 1).data;
      let rgb = `#${((1<<24)+(imageData[0]<<16)+(imageData[1]<<8)+imageData[2]).toString(16).slice(1)}`;
      brushColor = rgb;
      document.getElementById('brushColor').value = rgb;
      drawing = false;
      return;
    }
    // ...existing code...
    if(tool==='brush') {
      ctx.lineWidth = brushSize;
      ctx.lineCap = 'round';
      ctx.strokeStyle = brushColor;
      if(brushType === 'pencil') {
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.moveTo(lastDotX ?? startX, lastDotY ?? startY);
        ctx.lineTo(x, y);
        ctx.stroke();
        lastDotX = x;
        lastDotY = y;
        ctx.globalAlpha = 1;
      } else if(brushType === 'charcoal') {
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.arc(x, y, brushSize/2, 0, 2*Math.PI);
        ctx.fillStyle = brushColor;
        ctx.fill();
        ctx.globalAlpha = 1;
      } else if(brushType === 'graphite') {
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.moveTo(lastDotX ?? startX, lastDotY ?? startY);
        ctx.lineTo(x, y);
        ctx.stroke();
        lastDotX = x;
        lastDotY = y;
        ctx.globalAlpha = 1;
      } else if(brushType === 'ink') {
        ctx.globalAlpha = 1;
        ctx.lineWidth = brushSize/2;
        ctx.beginPath();
        ctx.moveTo(lastDotX ?? startX, lastDotY ?? startY);
        ctx.lineTo(x, y);
        ctx.stroke();
        lastDotX = x;
        lastDotY = y;
      } else if(brushType === 'marker') {
        ctx.globalAlpha = 0.7;
        ctx.lineWidth = brushSize*1.5;
        ctx.beginPath();
        ctx.moveTo(lastDotX ?? startX, lastDotY ?? startY);
        ctx.lineTo(x, y);
        ctx.stroke();
        lastDotX = x;
        lastDotY = y;
        ctx.globalAlpha = 1;
      } else if(brushType === 'airbrush') {
        spray(x, y, brushSize, brushColor);
      } else if(brushType === 'calligraphy') {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(Math.PI/8);
        ctx.fillStyle = brushColor;
        ctx.fillRect(-brushSize/2, -brushSize/8, brushSize, brushSize/4);
        ctx.restore();
      } else if(brushType === 'eraser') {
        ctx.save();
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(x, y, brushSize/2, 0, 2*Math.PI);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        ctx.restore();
      } else if(brushType === 'smudge') {
        ctx.globalAlpha = 0.2;
        ctx.beginPath();
        ctx.arc(x, y, brushSize/2, 0, 2*Math.PI);
        ctx.fillStyle = brushColor;
        ctx.fill();
        ctx.globalAlpha = 1;
      } else if(brushType === 'blend') {
        ctx.globalAlpha = 0.1;
        ctx.beginPath();
        ctx.arc(x, y, brushSize, 0, 2*Math.PI);
        ctx.fillStyle = brushColor;
        ctx.fill();
        ctx.globalAlpha = 1;
      } else if(brushType === 'spray') {
        spray(x, y, brushSize, brushColor);
      } else if(brushType === 'pattern') {
        // Use the pattern brush logic
        ctx.save();
        for(let dx=-brushSize; dx<brushSize; dx+=brushSize/2) {
          for(let dy=-brushSize; dy<brushSize; dy+=brushSize/2) {
            ctx.beginPath();
            ctx.rect(x+dx, y+dy, brushSize/2, brushSize/2);
            ctx.fillStyle = ((Math.floor(dx/(brushSize/2))+Math.floor(dy/(brushSize/2)))%2===0)?brushColor:'#fff';
            ctx.globalAlpha = 0.7;
            ctx.fill();
          }
        }
        ctx.globalAlpha = 1;
        ctx.restore();
      } else if(brushType === 'dotted') {
        drawDot(x, y, brushSize, brushColor);
      } else if(brushType === 'hatch') {
        hatch(x, y, brushSize, brushColor);
      } else if(brushType === 'crosshatch') {
        crosshatch(x, y, brushSize, brushColor);
      }
    } else if(['line','rect','circle','ellipse','polygon','text'].includes(tool)) {
      drawShape(e,false);
    }
  }

  function drawShape(e, final) {
    if(!drawing && !final) return;
    const {x, y} = getXY(e);
    ctx.putImageData(snapshot,0,0);
    ctx.lineWidth = brushSize;
    ctx.strokeStyle = brushColor;
    ctx.fillStyle = brushColor;
    if(tool==='line') { ctx.beginPath(); ctx.moveTo(startX,startY); ctx.lineTo(x,y); ctx.stroke(); }
    if(tool==='rect') { ctx.beginPath(); ctx.rect(startX,startY,x-startX,y-startY); ctx.stroke(); }
    if(tool==='circle') { ctx.beginPath(); let r = Math.sqrt((x-startX)**2+(y-startY)**2); ctx.arc(startX,startY,r,0,2*Math.PI); ctx.stroke(); }
    if(tool==='ellipse') { ctx.beginPath(); ctx.ellipse(startX,startY,Math.abs(x-startX),Math.abs(y-startY),0,0,2*Math.PI); ctx.stroke(); }
    if(tool==='polygon') {
      if (!isDrawingPolygon) {
        polygonPoints = [{x: startX, y: startY}];
        isDrawingPolygon = true;
      }
      polygonPoints.push({x, y});
      ctx.beginPath();
      ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
      for (let pt of polygonPoints) ctx.lineTo(pt.x, pt.y);
      ctx.stroke();
      if (final && polygonPoints.length > 2) {
        ctx.closePath();
        ctx.stroke();
        ctx.fill();
        isDrawingPolygon = false;
        polygonPoints = [];
      }
    }
    if(tool==='text' && final) {
      setTimeout(function() {
        let userText = prompt('Enter text:');
        if (userText) {
          ctx.font = `${brushSize*3}px Arial`;
          ctx.fillStyle = brushColor;
          ctx.fillText(userText, x, y);
        }
      }, 10);
    }
  }

  canvas.addEventListener('dblclick', function(e) {
    if(tool==='polygon' && isDrawingPolygon) {
      drawShape(e, true);
      isDrawingPolygon = false;
      polygonPoints = [];
    }
  });

  function clearCanvas() { ctx.clearRect(0, 0, canvas.width, canvas.height); }

  function saveDrawing() {
    const filename = prompt('Enter a name for your drawing:', 'my_sketch.png');
    if (!filename) return;
    // Save current canvas state
    const original = ctx.getImageData(0, 0, canvas.width, canvas.height);
    // Fill background with white
    ctx.save();
    ctx.globalCompositeOperation = 'destination-over';
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
    // Save PNG
    const dataURL = canvas.toDataURL('image/png');
    const link = document.createElement('a');
    link.href = dataURL;
    link.download = filename.endsWith('.png') ? filename : filename + '.png';
    link.click();
    // Restore original drawing
    ctx.putImageData(original, 0, 0);
    document.getElementById('saveMsg').textContent = 'Sketch saved as ' + link.download + '! Check your downloads.';
    setTimeout(()=>{ document.getElementById('saveMsg').textContent = ''; }, 3000);
  }

  // Simple flood fill (bucket tool)
  function floodFill(x, y, fillColor) {
    // Convert fillColor to RGBA
    function hexToRgba(hex) {
      let c = hex.replace('#', '');
      if (c.length === 3) c = c[0]+c[0]+c[1]+c[1]+c[2]+c[2];
      let num = parseInt(c, 16);
      return [num >> 16 & 255, num >> 8 & 255, num & 255, 255];
    }
    let canvasWidth = ctx.canvas.width;
    let canvasHeight = ctx.canvas.height;
    let imgData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
    let data = imgData.data;
    let stack = [[Math.floor(x), Math.floor(y)]];
    let targetIdx = (Math.floor(y) * canvasWidth + Math.floor(x)) * 4;
    let targetColor = [data[targetIdx], data[targetIdx+1], data[targetIdx+2], data[targetIdx+3]];
    let fillRgba = hexToRgba(fillColor);
    function colorsMatch(a, b) {
      return Math.abs(a[0]-b[0])<20 && Math.abs(a[1]-b[1])<20 && Math.abs(a[2]-b[2])<20 && Math.abs(a[3]-b[3])<20;
    }
    if (colorsMatch(targetColor, fillRgba)) return; // Already filled
    while (stack.length) {
      let [cx, cy] = stack.pop();
      if (cx < 0 || cy < 0 || cx >= canvasWidth || cy >= canvasHeight) continue;
      let idx = (cy * canvasWidth + cx) * 4;
      let pixel = [data[idx], data[idx+1], data[idx+2], data[idx+3]];
      if (colorsMatch(pixel, targetColor)) {
        data[idx] = fillRgba[0];
        data[idx+1] = fillRgba[1];
        data[idx+2] = fillRgba[2];
        data[idx+3] = fillRgba[3];
        stack.push([cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]);
      }
    }
    ctx.putImageData(imgData, 0, 0);
  }

  // Spray tool
  function spray(x, y, size, color) {
    for(let i=0;i<size*5;i++) {
      let angle = Math.random()*2*Math.PI;
      let radius = Math.random()*size;
      let sx = x + Math.cos(angle)*radius;
      let sy = y + Math.sin(angle)*radius;
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.2;
      ctx.fillRect(sx, sy, 1, 1);
    }
    ctx.globalAlpha = 1;
  }
  // Hatch tool
  function hatch(x, y, size, color) {
    ctx.strokeStyle = color;
    ctx.globalAlpha = 0.5;
    for(let i=-size;i<size;i+=4) {
      ctx.beginPath(); ctx.moveTo(x+i,y-size); ctx.lineTo(x+i,y+size); ctx.stroke(); }
    ctx.globalAlpha = 1;
  }
  // Crosshatch tool
  function crosshatch(x, y, size, color) {
    hatch(x, y, size, color);
    ctx.save(); ctx.translate(x, y); ctx.rotate(Math.PI/4);
    hatch(0, 0, size, color);
    ctx.restore();
  }

  // Add touch support for mobile drawing
  canvas.addEventListener('touchstart', function(e) {
    e.preventDefault();
    drawing = true;
    startDraw(e);
  });
  canvas.addEventListener('touchmove', function(e) {
    e.preventDefault();
    draw(e);
  });
  canvas.addEventListener('touchend', function(e) {
    e.preventDefault();
    endDraw(e);
  });
  canvas.addEventListener('touchcancel', function(e) {
    e.preventDefault();
    endDraw(e);
  });

  function drawDot(x, y, size, color) {
    ctx.save();
    ctx.beginPath();
    ctx.arc(x, y, size/2, 0, 2 * Math.PI);
    ctx.fillStyle = color;
    ctx.globalAlpha = 1;
    ctx.fill();
    ctx.restore();
  }

  const levels = [
    {text:'Draw a cat', icon:'üê±', img:'media/movies/download.jpeg'},
    {text:'Draw a house', icon:'üè†', img:'media/movies/635217f73e372771013edb4c-the-avengers-poster-marvel-movie-canvas1.jpg'},
    {text:'Draw a tree', icon:'üå≥', img:'media/movies/feUv2SYumXlT8E2RhzlYbZxfEGLG5AVrCPxP1gmAaCusxyPnA1.jpg'},
    {text:'Draw a car', icon:'üöó', img:'media/movies/f5VK0h2bprRhR6iRrixcuEfRxSUF4l14F66vQYrsJGmKZ5nTA1.jpg'},
    {text:'Draw a flower', icon:'üå∏', img:'media/movies/IQsBhg9t747dLhjXfsChIGZy4XfugER8BF0Gw5MDhIcnY5nTA1.jpg'},
    {text:'Draw a boat', icon:'‚õµ', img:'media/movies/feUv2SYumXlT8E2RhzlYbZxfEGLG5AVrCPxP1gmAaCusxyPnA1.jpg'},
    {text:'Draw a bird', icon:'üê¶', img:'media/movies/635217f73e372771013edb4c-the-avengers-poster-marvel-movie-canvas1.jpg'},
    {text:'Draw a sun', icon:'‚òÄÔ∏è', img:'media/movies/f5VK0h2bprRhR6iRrixcuEfRxSUF4l14F66vQYrsJGmKZ5nTA1.jpg'},
    {text:'Draw a fish', icon:'üêü', img:'media/movies/IQsBhg9t747dLhjXfsChIGZy4XfugER8BF0Gw5MDhIcnY5nTA1.jpg'},
    {text:'Draw a star', icon:'‚≠ê', img:'media/movies/download.jpeg'},
  {text:'Draw an apple', icon:'üçé', img:'https://res.cloudinary.com/djc3qirsl/image/upload/v1756897997/media/movies/uno1akwgos6rkbtrlqx6.webp'}
  ];
  let currentLevel = 0;
  function startSelfDrawing() {
    document.getElementById('modeSelect').style.display = 'none';
    document.getElementById('levelPrompt').style.display = 'none';
    document.getElementById('levelChooser').style.display = 'none';
    clearCanvas();
  }
  function showLevelChooser() {
    document.getElementById('modeSelect').style.display = 'none';
    document.getElementById('levelChooser').style.display = 'flex';
    renderLevelButtons();
  }
  function backToModeSelect() {
    document.getElementById('levelChooser').style.display = 'none';
    document.getElementById('modeSelect').style.display = 'flex';
  }
  function renderLevelButtons() {
    const levelBtns = document.getElementById('levelBtns');
    levelBtns.innerHTML = '';
    levels.forEach((level, idx) => {
      const btn = document.createElement('button');
      btn.className = 'kids-level-btn';
      btn.innerHTML = `<span class="kids-level-icon">${level.icon}</span> <span class="kids-level-text">${level.text}</span>`;
      btn.onclick = function() { startLevel(idx); };
      levelBtns.appendChild(btn);
    });
  }
  function startLevel(idx) {
    currentLevel = idx;
    document.getElementById('levelChooser').style.display = 'none';
    showLevelPrompt();
    clearCanvas();
  }
  function showLevelPrompt() {
    showLevelImage();
  }
  function showLevelImage() {
    const imgDiv = document.getElementById('levelSampleImg');
    if (!imgDiv) return;
  imgDiv.innerHTML = `<img src='${levels[currentLevel].img}' alt='Sample' style='max-width:320px;max-height:320px;border-radius:24px;border:4px solid #00b8ff;box-shadow:0 6px 24px #00b8ff44;'>`;
    imgDiv.style.display = 'block';
  }
  function nextLevel() {
    if(currentLevel < levels.length-1) {
      currentLevel++;
      showLevelPrompt();
      clearCanvas();
    } else {
      document.getElementById('levelPrompt').innerHTML = "<span style='font-size:2rem;'>üéâ</span> <span>All levels complete!</span> <button onclick='backToModeSelect()' class='kids-next-btn'>Choose Again</button>";
    }
  }

  // Image upload and draw on canvas
const imageLoader = document.getElementById('imageLoader');
if (imageLoader) {
  imageLoader.addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(event) {
      const img = new Image();
      img.onload = function() {
        // Clear canvas and draw the image centered and scaled
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let scale = Math.min(canvas.width / img.width, canvas.height / img.height, 1);
        let imgW = img.width * scale;
        let imgH = img.height * scale;
        let x = (canvas.width - imgW) / 2;
        let y = (canvas.height - imgH) / 2;
        ctx.drawImage(img, x, y, imgW, imgH);
        saveState();
      };
      img.src = event.target.result;
    };
    reader.readAsDataURL(file);
  });
}
</script>
<style>
.kids-modal {
  position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
  background: linear-gradient(135deg,#00b8ff33 0%,#fff 100%);
  z-index: 10000; display: flex; flex-direction: column; align-items: center; justify-content: center;
  animation: kidsPop 0.5s;
}
.kids-title {
  color: #00b8ff;
  font-size: 3.5rem;
  margin-bottom: 32px;
  font-family: 'Comic Sans MS', cursive, sans-serif;
  text-shadow: 2px 2px 0 #fff, 0 0 12px #00b8ff88;
}
.kids-mode-btns { display: flex; gap: 32px; }
.kids-mode-btn {
  font-size: 2.2rem;
  padding: 28px 56px;
  margin: 0 18px;
  border-radius: 24px;
  border: none;
  font-family: 'Comic Sans MS', cursive, sans-serif;
  box-shadow: 0 4px 18px #00b8ff44;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
}
.kids-mode-btn.self { background: #00b8ff; color: #fff; }
.kids-mode-btn.levels { background: #fff; color: #00b8ff; border: 2px solid #00b8ff; }
.kids-mode-btn:hover { transform: scale(1.08); box-shadow: 0 4px 24px #00b8ff88; }
.kids-level-btns { display: flex; flex-wrap: wrap; gap: 18px; justify-content: center; margin-bottom: 24px; }
.kids-level-btns-scroll {
  max-height: 48vh;
  overflow-y: auto;
  padding: 8px 0;
}
.kids-level-btn {
  background: #fff;
  color: #00b8ff;
  border: 2px solid #00b8ff;
  border-radius: 24px;
  font-size: 2rem;
  font-family: 'Comic Sans MS', cursive, sans-serif;
  padding: 28px 48px;
  min-width: 240px;
  min-height: 80px;
  box-shadow: 0 4px 18px #00b8ff44;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 18px;
  transition: transform 0.2s, box-shadow 0.2s;
}
.kids-level-btn:hover { background: #00b8ff; color: #fff; transform: scale(1.07); box-shadow: 0 4px 24px #00b8ff88; }
.kids-level-icon { font-size: 3rem; }
.kids-level-text { font-size: 2rem; font-weight: 700; }
  .kids-back-btn {
    background: #eee;
    color: #00b8ff;
    border: none;
    border-radius: 18px;
    font-size: 2rem;
    padding: 18px 48px;
    margin-top: 18px;
    cursor: pointer;
    font-family: 'Comic Sans MS', cursive, sans-serif;
    box-shadow: 0 2px 12px #00b8ff44;
  }
.kids-back-btn:hover { background: #00b8ff; color: #fff; }
.kids-level-prompt {
  display: none; position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
  background: #fff; color: #00b8ff; padding: 18px 36px; border-radius: 16px; box-shadow: 0 2px 16px #00b8ff44; font-size: 1.5rem; z-index: 9999;
  font-family: 'Comic Sans MS', cursive, sans-serif;
  text-align: center;
}
.kids-next-btn {
  background: #00b8ff; color: #fff; border: none; border-radius: 10px; font-size: 1.1rem; padding: 8px 18px; margin-left: 18px; cursor: pointer; font-family: 'Comic Sans MS', cursive, sans-serif;
}
.kids-next-btn:hover { background: #fff; color: #00b8ff; border: 2px solid #00b8ff; }
@keyframes kidsPop { 0% { transform: scale(0.7); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
</style>
</body>
</html>
